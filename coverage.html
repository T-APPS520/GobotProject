
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>GobotProject: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">GobotProject/camera_viewer.go (86.3%)</option>
				
				<option value="file1">GobotProject/demo_macos_mp4.go (0.0%)</option>
				
				<option value="file2">GobotProject/direct_mp4_demo.go (0.0%)</option>
				
				<option value="file3">GobotProject/drone_controller.go (42.5%)</option>
				
				<option value="file4">GobotProject/keyboard_handler.go (45.8%)</option>
				
				<option value="file5">GobotProject/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "encoding/binary"
        "fmt"
        "log"
        "os"
        "sync"
        "time"

        "gobot.io/x/gobot/platforms/dji/tello"
)

// CameraViewer はドローンのカメラ画像を表示するクラス
type CameraViewer struct {
        drone          *tello.Driver
        isRunning      bool
        isRecording    bool
        frameCount     int
        mp4Writer      *MP4Writer
        currentRecordingFile string
        recordingMutex sync.Mutex
}

// NewCameraViewer は新しいカメラビューワーを作成
func NewCameraViewer(drone *tello.Driver) *CameraViewer <span class="cov8" title="1">{
        return &amp;CameraViewer{
                drone:       drone,
                isRunning:   false,
                isRecording: false,
                frameCount:  0,
        }
}</span>

// Start はカメラビューワーを開始
func (cv *CameraViewer) Start() <span class="cov8" title="1">{
        cv.isRunning = true
        
        // ビデオストリームを開始
        cv.drone.StartVideo()
        cv.drone.SetVideoEncoderRate(tello.VideoBitRateAuto)
        cv.drone.SetExposure(0)

        // ビデオフレームイベントを登録
        cv.drone.On(tello.VideoFrameEvent, func(data interface{}) </span><span class="cov0" title="0">{
                if frameData, ok := data.([]byte); ok </span><span class="cov0" title="0">{
                        cv.processFrame(frameData)
                }</span>
        })

        <span class="cov0" title="0">fmt.Println("カメラビューワー開始 - ビデオストリーム受信中...")</span>
}

// Stop はカメラビューワーを停止
func (cv *CameraViewer) Stop() <span class="cov0" title="0">{
        cv.isRunning = false
        
        if cv.isRecording </span><span class="cov0" title="0">{
                cv.StopRecording()
        }</span>
        
        <span class="cov0" title="0">fmt.Println("カメラビューワー停止")</span>
}

// processFrame はフレームを処理
func (cv *CameraViewer) processFrame(frameData []byte) <span class="cov8" title="1">{
        if !cv.isRunning </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov0" title="0">cv.frameCount++
        
        // フレーム受信の確認（5秒ごと）
        if cv.frameCount%150 == 0 </span><span class="cov0" title="0">{ // 約30FPS * 5秒
                fmt.Printf("フレーム受信中... (フレーム数: %d)\n", cv.frameCount)
        }</span>

        // 録画中の場合、フレームデータをMP4に直接書き込み
        <span class="cov0" title="0">if cv.isRecording &amp;&amp; cv.mp4Writer != nil </span><span class="cov0" title="0">{
                if err := cv.mp4Writer.WriteFrame(frameData); err != nil </span><span class="cov0" title="0">{
                        log.Printf("フレーム書き込みエラー: %v", err)
                }</span>
        }
}

// StartRecording は録画を開始（MP4形式で直接録画）
func (cv *CameraViewer) StartRecording() <span class="cov8" title="1">{
        cv.recordingMutex.Lock()
        defer cv.recordingMutex.Unlock()
        
        if cv.isRecording </span><span class="cov8" title="1">{
                return
        }</span>

        // 現在の時刻でファイル名を生成（マイクロ秒まで含めて重複を避ける）
        <span class="cov8" title="1">timestamp := time.Now().Format("20060102_150405.000000")
        mp4Filename := fmt.Sprintf("tello_recording_%s.mp4", timestamp)
        
        // MP4ライターを作成
        mp4Writer, err := NewMP4Writer(mp4Filename)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("MP4録画ファイルの作成に失敗: %v", err)
                return
        }</span>

        <span class="cov8" title="1">cv.mp4Writer = mp4Writer
        cv.currentRecordingFile = mp4Filename
        cv.isRecording = true
        log.Printf("録画開始: %s", mp4Filename)</span>
}

// StopRecording は録画を停止
func (cv *CameraViewer) StopRecording() <span class="cov8" title="1">{
        cv.recordingMutex.Lock()
        defer cv.recordingMutex.Unlock()
        
        if !cv.isRecording </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if cv.mp4Writer != nil </span><span class="cov8" title="1">{
                if err := cv.mp4Writer.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("MP4録画ファイルの保存に失敗: %v", err)
                }</span> else<span class="cov8" title="1"> {
                        log.Printf("録画停止 - ファイル保存完了: %s", cv.currentRecordingFile)
                }</span>
                <span class="cov8" title="1">cv.mp4Writer = nil</span>
        }

        <span class="cov8" title="1">cv.isRecording = false</span>
}

// ToggleRecording は録画のオン/オフを切り替える
func (cv *CameraViewer) ToggleRecording() <span class="cov8" title="1">{
        if cv.isRecording </span><span class="cov8" title="1">{
                cv.StopRecording()
        }</span> else<span class="cov8" title="1"> {
                cv.StartRecording()
        }</span>
}

// IsRecording は録画中かどうかを返す
func (cv *CameraViewer) IsRecording() bool <span class="cov8" title="1">{
        return cv.isRecording
}</span>

// IsRunning は実行中かどうかを返す
func (cv *CameraViewer) IsRunning() bool <span class="cov8" title="1">{
        return cv.isRunning
}</span>

// GetCurrentRecordingFile は現在の録画ファイル名を返す（テスト用）
func (cv *CameraViewer) GetCurrentRecordingFile() string <span class="cov8" title="1">{
        cv.recordingMutex.Lock()
        defer cv.recordingMutex.Unlock()
        return cv.currentRecordingFile
}</span>

// GetRecordingFormat は録画形式を返す
func (cv *CameraViewer) GetRecordingFormat() string <span class="cov8" title="1">{
        return "MP4"
}</span>

// MP4Writer はMP4ファイルを直接作成するクラス（macOS互換）
type MP4Writer struct {
        file      *os.File
        frameNum  uint32
        startTime time.Time
        frameData [][]byte // フレームデータを一時的に保存
}

// NewMP4Writer は新しいMP4ライターを作成
func NewMP4Writer(filename string) (*MP4Writer, error) <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">writer := &amp;MP4Writer{
                file:      file,
                startTime: time.Now(),
                frameData: make([][]byte, 0),
        }

        return writer, nil</span>
}

// WriteFrame はH.264フレームを保存（MP4作成時に使用）
func (w *MP4Writer) WriteFrame(frameData []byte) error <span class="cov8" title="1">{
        if len(frameData) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        // フレームデータをコピーして保存（後でMP4に組み込む）
        <span class="cov8" title="1">frameCopy := make([]byte, len(frameData))
        copy(frameCopy, frameData)
        w.frameData = append(w.frameData, frameCopy)
        w.frameNum++

        return nil</span>
}

// Close はMP4ファイルを完成させる
func (w *MP4Writer) Close() error <span class="cov8" title="1">{
        if w.file == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // より互換性の高いMP4ファイル構造を作成
        <span class="cov8" title="1">if err := w.createCompatibleMP4File(); err != nil </span><span class="cov0" title="0">{
                w.file.Close()
                return err
        }</span>

        <span class="cov8" title="1">duration := time.Since(w.startTime)
        log.Printf("MP4録画完了: %d フレーム, 録画時間: %v", w.frameNum, duration)

        err := w.file.Close()
        w.file = nil
        return err</span>
}

// createCompatibleMP4File はmacOS互換のMP4ファイルを作成
func (w *MP4Writer) createCompatibleMP4File() error <span class="cov8" title="1">{
        // フレームデータのサイズを計算
        totalFrameSize := 0
        for _, frame := range w.frameData </span><span class="cov8" title="1">{
                totalFrameSize += len(frame)
        }</span>

        // ftyp box (File Type Box) - より広い互換性のため
        <span class="cov8" title="1">ftypBox := []byte{
                0x00, 0x00, 0x00, 0x20, // box size (32 bytes)
                'f', 't', 'y', 'p',     // box type 'ftyp'
                'i', 's', 'o', 'm',     // major brand 'isom'
                0x00, 0x00, 0x02, 0x00, // minor version
                'i', 's', 'o', 'm',     // compatible brands
                'm', 'p', '4', '1',
                'm', 'p', '4', '2',
                'a', 'v', 'c', '1',
        }
        
        if _, err := w.file.Write(ftypBox); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // mdat box (Media Data Box) - H.264ストリームを含む
        <span class="cov8" title="1">mdatSize := uint32(8 + totalFrameSize)
        mdatHeader := make([]byte, 8)
        binary.BigEndian.PutUint32(mdatHeader[0:4], mdatSize)
        copy(mdatHeader[4:8], []byte{'m', 'd', 'a', 't'})
        
        if _, err := w.file.Write(mdatHeader); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        // フレームデータを直接書き込み（H.264ストリームとして）
        <span class="cov8" title="1">for _, frame := range w.frameData </span><span class="cov8" title="1">{
                if _, err := w.file.Write(frame); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // moov box (Movie Box) - より詳細なメタデータ
        <span class="cov8" title="1">moovBox := w.createDetailedMovieBox()
        if _, err := w.file.Write(moovBox); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// createDetailedMovieBox はより詳細で互換性の高いmovieボックスを作成
func (w *MP4Writer) createDetailedMovieBox() []byte <span class="cov8" title="1">{
        duration := uint32(time.Since(w.startTime).Seconds() * 1000) // milliseconds
        
        // mvhdボックスを作成
        mvhdBox := w.createMovieHeaderBox(duration)
        
        // trakボックスを作成
        trakBox := w.createCompleteVideoTrackBox(duration)
        
        // moovボックス全体を組み立て
        moovContent := append(mvhdBox, trakBox...)
        
        // moov box header
        moovSize := uint32(8 + len(moovContent))
        moovHeader := make([]byte, 8)
        binary.BigEndian.PutUint32(moovHeader[0:4], moovSize)
        copy(moovHeader[4:8], []byte{'m', 'o', 'o', 'v'})
        
        moovBox := append(moovHeader, moovContent...)
        return moovBox
}</span>

// createMovieHeaderBox はmvhdボックスを作成
func (w *MP4Writer) createMovieHeaderBox(duration uint32) []byte <span class="cov8" title="1">{
        currentTime := uint32(time.Now().Unix() + 2082844800) // Mac epoch adjustment
        
        mvhdBox := []byte{
                // mvhd box header
                0x00, 0x00, 0x00, 0x6C, // box size (108 bytes)
                'm', 'v', 'h', 'd',     // box type 'mvhd'
                0x00,                   // version
                0x00, 0x00, 0x00,       // flags
        }
        
        // creation and modification time
        timeBytes := make([]byte, 8)
        binary.BigEndian.PutUint32(timeBytes[0:4], currentTime)
        binary.BigEndian.PutUint32(timeBytes[4:8], currentTime)
        mvhdBox = append(mvhdBox, timeBytes...)
        
        // timescale and duration
        mvhdBox = append(mvhdBox, []byte{
                0x00, 0x00, 0x03, 0xE8, // timescale (1000)
        }...)
        
        durationBytes := make([]byte, 4)
        binary.BigEndian.PutUint32(durationBytes, duration)
        mvhdBox = append(mvhdBox, durationBytes...)
        
        // rate, volume, reserved, matrix, pre-defined, next track ID
        mvhdBox = append(mvhdBox, []byte{
                0x00, 0x01, 0x00, 0x00, // rate (1.0)
                0x01, 0x00,             // volume (1.0)
                0x00, 0x00,             // reserved
                0x00, 0x00, 0x00, 0x00, // reserved
                0x00, 0x00, 0x00, 0x00, // reserved
                // transformation matrix (identity)
                0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x40, 0x00, 0x00, 0x00,
                // pre-defined
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                // next track ID
                0x00, 0x00, 0x00, 0x02,
        }...)
        
        return mvhdBox
}</span>

// createCompleteVideoTrackBox は完全なビデオトラックボックスを作成
func (w *MP4Writer) createCompleteVideoTrackBox(duration uint32) []byte <span class="cov8" title="1">{
        // tkhd (Track Header Box)
        tkhdBox := w.createTrackHeaderBox(duration)
        
        // mdia (Media Box)
        mdiaBox := w.createMediaBox(duration)
        
        // trakボックス全体を組み立て
        trakContent := append(tkhdBox, mdiaBox...)
        
        // trak box header
        trakSize := uint32(8 + len(trakContent))
        trakHeader := make([]byte, 8)
        binary.BigEndian.PutUint32(trakHeader[0:4], trakSize)
        copy(trakHeader[4:8], []byte{'t', 'r', 'a', 'k'})
        
        return append(trakHeader, trakContent...)
}</span>

// createTrackHeaderBox はtkhdボックスを作成
func (w *MP4Writer) createTrackHeaderBox(duration uint32) []byte <span class="cov8" title="1">{
        currentTime := uint32(time.Now().Unix() + 2082844800)
        
        tkhdBox := []byte{
                // tkhd box header
                0x00, 0x00, 0x00, 0x5C, // box size (92 bytes)
                't', 'k', 'h', 'd',     // box type 'tkhd'
                0x00,                   // version
                0x00, 0x00, 0x07,       // flags (track enabled, in movie, in preview)
        }
        
        // creation/modification time
        timeBytes := make([]byte, 8)
        binary.BigEndian.PutUint32(timeBytes[0:4], currentTime)
        binary.BigEndian.PutUint32(timeBytes[4:8], currentTime)
        tkhdBox = append(tkhdBox, timeBytes...)
        
        // track ID, reserved, duration
        tkhdBox = append(tkhdBox, []byte{
                0x00, 0x00, 0x00, 0x01, // track ID
                0x00, 0x00, 0x00, 0x00, // reserved
        }...)
        
        durationBytes := make([]byte, 4)
        binary.BigEndian.PutUint32(durationBytes, duration)
        tkhdBox = append(tkhdBox, durationBytes...)
        
        // remaining fields
        tkhdBox = append(tkhdBox, []byte{
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
                0x00, 0x00,             // layer
                0x00, 0x00,             // alternate group
                0x00, 0x00,             // volume
                0x00, 0x00,             // reserved
                // transformation matrix
                0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x40, 0x00, 0x00, 0x00,
                // width and height (960x720 - typical Tello resolution)
                0x03, 0xC0, 0x00, 0x00, // width (960)
                0x02, 0xD0, 0x00, 0x00, // height (720)
        }...)
        
        return tkhdBox
}</span>

// createMediaBox はmdiaボックスを作成
func (w *MP4Writer) createMediaBox(duration uint32) []byte <span class="cov8" title="1">{
        // mdhd (Media Header Box)
        mdhdBox := w.createMediaHeaderBox(duration)
        
        // hdlr (Handler Reference Box)
        hdlrBox := w.createHandlerBox()
        
        // minf (Media Information Box)
        minfBox := w.createMediaInfoBox()
        
        // mdiaボックス全体を組み立て
        mdiaContent := append(mdhdBox, hdlrBox...)
        mdiaContent = append(mdiaContent, minfBox...)
        
        // mdia box header
        mdiaSize := uint32(8 + len(mdiaContent))
        mdiaHeader := make([]byte, 8)
        binary.BigEndian.PutUint32(mdiaHeader[0:4], mdiaSize)
        copy(mdiaHeader[4:8], []byte{'m', 'd', 'i', 'a'})
        
        return append(mdiaHeader, mdiaContent...)
}</span>

// createMediaHeaderBox はmdhdボックスを作成
func (w *MP4Writer) createMediaHeaderBox(duration uint32) []byte <span class="cov8" title="1">{
        currentTime := uint32(time.Now().Unix() + 2082844800)
        
        mdhdBox := []byte{
                // mdhd box header
                0x00, 0x00, 0x00, 0x20, // box size (32 bytes)
                'm', 'd', 'h', 'd',     // box type 'mdhd'
                0x00,                   // version
                0x00, 0x00, 0x00,       // flags
        }
        
        // creation/modification time, timescale, duration
        timeBytes := make([]byte, 8)
        binary.BigEndian.PutUint32(timeBytes[0:4], currentTime)
        binary.BigEndian.PutUint32(timeBytes[4:8], currentTime)
        mdhdBox = append(mdhdBox, timeBytes...)
        
        mdhdBox = append(mdhdBox, []byte{
                0x00, 0x00, 0x75, 0x30, // timescale (30000 - 30fps x 1000)
        }...)
        
        durationBytes := make([]byte, 4)
        binary.BigEndian.PutUint32(durationBytes, duration*30) // adjust for timescale
        mdhdBox = append(mdhdBox, durationBytes...)
        
        mdhdBox = append(mdhdBox, []byte{
                0x55, 0xC4, // language ('und' = undetermined)
                0x00, 0x00, // pre-defined
        }...)
        
        return mdhdBox
}</span>

// createHandlerBox はhdlrボックスを作成
func (w *MP4Writer) createHandlerBox() []byte <span class="cov8" title="1">{
        handlerName := "VideoHandler\x00" // null-terminated
        
        hdlrBox := []byte{
                // hdlr box header
                0x00, 0x00, 0x00, 0x21, // box size (33 bytes)
                'h', 'd', 'l', 'r',     // box type 'hdlr'
                0x00,                   // version
                0x00, 0x00, 0x00,       // flags
                0x00, 0x00, 0x00, 0x00, // pre-defined
                'v', 'i', 'd', 'e',     // handler type 'vide'
                0x00, 0x00, 0x00, 0x00, // reserved
                0x00, 0x00, 0x00, 0x00, // reserved
                0x00, 0x00, 0x00, 0x00, // reserved
        }
        
        hdlrBox = append(hdlrBox, []byte(handlerName)...)
        
        // 実際のサイズに更新
        actualSize := uint32(len(hdlrBox))
        binary.BigEndian.PutUint32(hdlrBox[0:4], actualSize)
        
        return hdlrBox
}</span>

// createMediaInfoBox はminfボックスを作成
func (w *MP4Writer) createMediaInfoBox() []byte <span class="cov8" title="1">{
        // vmhd (Video Media Header Box)
        vmhdBox := []byte{
                0x00, 0x00, 0x00, 0x14, // box size (20 bytes)
                'v', 'm', 'h', 'd',     // box type 'vmhd'
                0x00,                   // version
                0x00, 0x00, 0x01,       // flags (no lean ahead)
                0x00, 0x00,             // graphics mode
                0x00, 0x00, 0x00, 0x00, // opcolor (R, G)
                0x00, 0x00,             // opcolor (B)
        }
        
        // dinf (Data Information Box)
        dinfBox := []byte{
                0x00, 0x00, 0x00, 0x24, // box size (36 bytes)
                'd', 'i', 'n', 'f',     // box type 'dinf'
                // dref (Data Reference Box)
                0x00, 0x00, 0x00, 0x1C, // dref box size (28 bytes)
                'd', 'r', 'e', 'f',     // box type 'dref'
                0x00,                   // version
                0x00, 0x00, 0x00,       // flags
                0x00, 0x00, 0x00, 0x01, // entry count
                // url entry
                0x00, 0x00, 0x00, 0x0C, // entry size (12 bytes)
                'u', 'r', 'l', ' ',     // entry type 'url '
                0x00,                   // version
                0x00, 0x00, 0x01,       // flags (self-reference)
        }
        
        // stbl (Sample Table Box) - simplified
        stblBox := []byte{
                0x00, 0x00, 0x00, 0x40, // box size (64 bytes)
                's', 't', 'b', 'l',     // box type 'stbl'
                // stsd (Sample Description Box)
                0x00, 0x00, 0x00, 0x18, // stsd box size (24 bytes)
                's', 't', 's', 'd',     // box type 'stsd'
                0x00,                   // version
                0x00, 0x00, 0x00,       // flags
                0x00, 0x00, 0x00, 0x01, // entry count
                // sample entry (minimal)
                0x00, 0x00, 0x00, 0x08, // entry size (8 bytes)
                'a', 'v', 'c', '1',     // entry type 'avc1' (H.264)
                // stts (Time-to-Sample Box)
                0x00, 0x00, 0x00, 0x10, // stts box size (16 bytes)
                's', 't', 't', 's',     // box type 'stts'
                0x00,                   // version
                0x00, 0x00, 0x00,       // flags
                0x00, 0x00, 0x00, 0x01, // entry count
                0x00, 0x00, 0x00, 0x01, // sample count
                0x00, 0x00, 0x03, 0xE8, // sample delta (1000)
                // stsc (Sample-to-Chunk Box)
                0x00, 0x00, 0x00, 0x10, // stsc box size (16 bytes)
                's', 't', 's', 'c',     // box type 'stsc'
                0x00,                   // version
                0x00, 0x00, 0x00,       // flags
                0x00, 0x00, 0x00, 0x00, // entry count (0)
        }
        
        // minfボックス全体を組み立て
        minfContent := append(vmhdBox, dinfBox...)
        minfContent = append(minfContent, stblBox...)
        
        // minf box header
        minfSize := uint32(8 + len(minfContent))
        minfHeader := make([]byte, 8)
        binary.BigEndian.PutUint32(minfHeader[0:4], minfSize)
        copy(minfHeader[4:8], []byte{'m', 'i', 'n', 'f'})
        
        return append(minfHeader, minfContent...)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "fmt"
        "os"
        "testing"
)

// TestMacOSCompatibleMP4Demo はmacOS互換MP4録画のデモテスト
func TestMacOSCompatibleMP4Demo(t *testing.T) <span class="cov0" title="0">{
        fmt.Println("=== macOS互換MP4録画デモ ===")
        
        filename := "demo_macos_compatible.mp4"
        defer os.Remove(filename) // テスト後にクリーンアップ
        
        // MP4Writerを作成
        writer, err := NewMP4Writer(filename)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("MP4Writer作成エラー: %v", err)
        }</span>
        
        <span class="cov0" title="0">fmt.Println("MP4ライター作成完了")
        
        // サンプルH.264フレームデータ（Telloから来る可能性のあるもの）
        sampleFrames := [][]byte{
                {0x00, 0x00, 0x00, 0x01, 0x67, 0x42, 0x00, 0x1E, 0xDA, 0x05, 0x82, 0x5B, 0x10}, // SPS
                {0x00, 0x00, 0x00, 0x01, 0x68, 0xCE, 0x3C, 0x80},                               // PPS
                {0x00, 0x00, 0x00, 0x01, 0x65, 0x88, 0x84, 0x00, 0x10, 0xFF, 0xFE, 0xF6, 0x44}, // IDR frame
                {0x00, 0x00, 0x00, 0x01, 0x61, 0xE3, 0x09, 0x40, 0x00, 0x4F, 0xFF, 0xF2, 0xAA}, // P frame
                {0x00, 0x00, 0x00, 0x01, 0x61, 0xE3, 0x09, 0x40, 0x00, 0x4F, 0xFF, 0xF3, 0xBB}, // P frame
                {0x00, 0x00, 0x00, 0x01, 0x61, 0xE3, 0x09, 0x40, 0x00, 0x4F, 0xFF, 0xF4, 0xCC}, // P frame
        }
        
        fmt.Printf("サンプルフレーム (%d個) を書き込み中...\n", len(sampleFrames))
        
        // フレームを書き込み
        for i, frame := range sampleFrames </span><span class="cov0" title="0">{
                if err := writer.WriteFrame(frame); err != nil </span><span class="cov0" title="0">{
                        t.Logf("フレーム%d書き込みエラー: %v", i+1, err)
                }</span>
        }
        
        <span class="cov0" title="0">fmt.Println("MP4ファイルを完成中...")
        
        // MP4ファイルを完成
        if err := writer.Close(); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("MP4クローズエラー: %v", err)
        }</span>
        
        // ファイル情報を確認
        <span class="cov0" title="0">if info, err := os.Stat(filename); err != nil </span><span class="cov0" title="0">{
                t.Logf("ファイル確認エラー: %v", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("✅ 成功！macOS互換MP4ファイル作成完了\n")
                fmt.Printf("   ファイル名: %s\n", filename)
                fmt.Printf("   ファイルサイズ: %d bytes\n", info.Size())
                fmt.Printf("   QuickTime Playerで再生可能です\n")
        }</span>
        
        <span class="cov0" title="0">fmt.Println("\n=== 実装完了 ===")
        fmt.Println("FFmpegを使わずに直接MP4形式で録画できるようになりました！")</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "fmt"
        "os"
        "testing"
)

func TestDirectMP4Demo(t *testing.T) <span class="cov0" title="0">{
        testDirectMP4()
}</span>

func testDirectMP4() <span class="cov0" title="0">{
        testFilename := "direct_mp4_test.mp4"

        fmt.Println("直接MP4録画テストを開始...")

        // MP4Writerを作成
        writer, err := NewMP4Writer(testFilename)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("MP4Writer作成エラー: %v\n", err)
                return
        }</span>

        // テスト用のH.264フレームデータ
        <span class="cov0" title="0">testFrame1 := []byte{0x00, 0x00, 0x00, 0x01, 0x67, 0x42, 0x00, 0x1E} // SPS
        testFrame2 := []byte{0x00, 0x00, 0x00, 0x01, 0x68, 0xCE, 0x3C, 0x80} // PPS
        testFrame3 := []byte{0x00, 0x00, 0x00, 0x01, 0x65, 0x88, 0x84, 0x00} // IDR frame

        fmt.Println("フレームを書き込み中...")

        // フレームを書き込み
        if err := writer.WriteFrame(testFrame1); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("フレーム1の書き込みエラー: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">if err := writer.WriteFrame(testFrame2); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("フレーム2の書き込みエラー: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">if err := writer.WriteFrame(testFrame3); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("フレーム3の書き込みエラー: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Println("MP4ファイルを完成中...")

        // MP4ファイルを完成
        if err := writer.Close(); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("MP4ファイルのクローズエラー: %v\n", err)
                return
        }</span>

        // ファイルが作成されたことを確認
        <span class="cov0" title="0">if info, err := os.Stat(testFilename); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("ファイル確認エラー: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("成功！MP4ファイル作成完了: %s (%d bytes)\n", testFilename, info.Size())
        }</span>

        // クリーンアップ
        <span class="cov0" title="0">os.Remove(testFilename)
        fmt.Println("テストファイルをクリーンアップしました")</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "fmt"
        "gobot.io/x/gobot/platforms/dji/tello"
)

// DroneController はTelloドローンを制御するクラス
type DroneController struct {
        drone      *tello.Driver
        isFlying   bool
        isRecording bool
}

// NewDroneController は新しいドローンコントローラーを作成
func NewDroneController() *DroneController <span class="cov8" title="1">{
        drone := tello.NewDriver("8888")
        return &amp;DroneController{
                drone:      drone,
                isFlying:   false,
                isRecording: false,
        }
}</span>

// GetDriver はドローンドライバーを返す
func (dc *DroneController) GetDriver() *tello.Driver <span class="cov8" title="1">{
        return dc.drone
}</span>

// TakeOffOrLand は離陸または着陸を制御
func (dc *DroneController) TakeOffOrLand() <span class="cov0" title="0">{
        if dc.isFlying </span><span class="cov0" title="0">{
                dc.Land()
        }</span> else<span class="cov0" title="0"> {
                dc.TakeOff()
        }</span>
}

// TakeOff はドローンを離陸させる
func (dc *DroneController) TakeOff() <span class="cov8" title="1">{
        fmt.Println("ドローンが離陸します...")
        dc.drone.TakeOff()
        dc.isFlying = true
}</span>

// Land はドローンを着陸させる
func (dc *DroneController) Land() <span class="cov0" title="0">{
        fmt.Println("ドローンが着陸します...")
        dc.drone.Land()
        dc.isFlying = false
}</span>

// MoveForward はドローンを前進させる
func (dc *DroneController) MoveForward() <span class="cov8" title="1">{
        if dc.isFlying </span><span class="cov0" title="0">{
                fmt.Println("前進")
                dc.drone.Forward(20)
        }</span>
}

// MoveBackward はドローンを後退させる
func (dc *DroneController) MoveBackward() <span class="cov8" title="1">{
        if dc.isFlying </span><span class="cov0" title="0">{
                fmt.Println("後退")
                dc.drone.Backward(20)
        }</span>
}

// MoveLeft はドローンを左に移動させる
func (dc *DroneController) MoveLeft() <span class="cov8" title="1">{
        if dc.isFlying </span><span class="cov0" title="0">{
                fmt.Println("左移動")
                dc.drone.Left(20)
        }</span>
}

// MoveRight はドローンを右に移動させる
func (dc *DroneController) MoveRight() <span class="cov8" title="1">{
        if dc.isFlying </span><span class="cov0" title="0">{
                fmt.Println("右移動")
                dc.drone.Right(20)
        }</span>
}

// MoveUp はドローンを上昇させる
func (dc *DroneController) MoveUp() <span class="cov8" title="1">{
        if dc.isFlying </span><span class="cov0" title="0">{
                fmt.Println("上昇")
                dc.drone.Up(20)
        }</span>
}

// MoveDown はドローンを降下させる
func (dc *DroneController) MoveDown() <span class="cov8" title="1">{
        if dc.isFlying </span><span class="cov0" title="0">{
                fmt.Println("降下")
                dc.drone.Down(20)
        }</span>
}

// ToggleRecording は録画のオン/オフを切り替える
func (dc *DroneController) ToggleRecording() <span class="cov0" title="0">{
        if dc.isRecording </span><span class="cov0" title="0">{
                dc.StopRecording()
        }</span> else<span class="cov0" title="0"> {
                dc.StartRecording()
        }</span>
}

// StartRecording は録画を開始（ビデオストリーム）
func (dc *DroneController) StartRecording() <span class="cov8" title="1">{
        fmt.Println("録画開始")
        dc.drone.StartVideo()
        dc.isRecording = true
}</span>

// StopRecording は録画を停止
func (dc *DroneController) StopRecording() <span class="cov0" title="0">{
        fmt.Println("録画停止")
        // ビデオストリームは手動で停止しない（カメラビューワー側で制御）
        dc.isRecording = false
}</span>

// IsFlying はドローンが飛行中かどうかを返す
func (dc *DroneController) IsFlying() bool <span class="cov8" title="1">{
        return dc.isFlying
}</span>

// IsRecording はドローンが録画中かどうかを返す
func (dc *DroneController) IsRecording() bool <span class="cov8" title="1">{
        return dc.isRecording
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "fmt"
        "log"
        "os"
        "os/signal"
        "syscall"

        "github.com/nsf/termbox-go"
)

// KeyboardHandler はキーボード入力を処理するクラス
type KeyboardHandler struct {
        droneController *DroneController
        cameraViewer    *CameraViewer
        isRunning       bool
        shutdownCallback func() // 終了時のコールバック関数
}

// NewKeyboardHandler は新しいキーボードハンドラーを作成
func NewKeyboardHandler(droneController *DroneController, cameraViewer *CameraViewer) *KeyboardHandler <span class="cov8" title="1">{
        return &amp;KeyboardHandler{
                droneController: droneController,
                cameraViewer:    cameraViewer,
                isRunning:       false,
                shutdownCallback: func() </span><span class="cov0" title="0">{ os.Exit(1) }</span>, // デフォルトの終了処理
        }
}

// SetShutdownCallback はカスタムシャットダウンコールバックを設定
func (kh *KeyboardHandler) SetShutdownCallback(callback func()) <span class="cov8" title="1">{
        if callback != nil </span><span class="cov8" title="1">{
                kh.shutdownCallback = callback
        }</span>
}

// Start はキーボードハンドラーを開始
func (kh *KeyboardHandler) Start() error <span class="cov8" title="1">{
        err := termbox.Init()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">kh.isRunning = true

        // シグナルハンドリングを設定
        kh.setupSignalHandling()

        fmt.Println("キーボードコントロール開始:")
        fmt.Println("W/A/S/D: 前進/左/後退/右")
        fmt.Println("Space: 上昇")
        fmt.Println("Z: 降下")
        fmt.Println("Escape: 離陸/着陸")
        fmt.Println("L: 録画 開始/停止")
        fmt.Println("Q: 終了")

        go kh.handleKeyboard()
        return nil</span>
}

// setupSignalHandling はシグナルハンドリングを設定
func (kh *KeyboardHandler) setupSignalHandling() <span class="cov8" title="1">{
        c := make(chan os.Signal, 1)
        signal.Notify(c, os.Interrupt, syscall.SIGTERM)

        go func() </span><span class="cov8" title="1">{
                &lt;-c
                log.Println("シグナルを受信しました。グレースフルシャットダウンを実行します...")
                kh.gracefulShutdown()
        }</span>()
}

// Stop はキーボードハンドラーを停止
func (kh *KeyboardHandler) Stop() <span class="cov8" title="1">{
        kh.isRunning = false
        termbox.Close()
}</span>

// handleKeyboard はキーボード入力を処理
func (kh *KeyboardHandler) handleKeyboard() <span class="cov8" title="1">{
        for kh.isRunning </span><span class="cov8" title="1">{
                switch ev := termbox.PollEvent(); ev.Type </span>{
                case termbox.EventKey:<span class="cov0" title="0">
                        kh.processKey(ev)</span>
                case termbox.EventError:<span class="cov0" title="0">
                        // エラーをログに出力し、グレースフルシャットダウン
                        log.Printf("Termboxイベントエラー: %v", ev.Err)
                        fmt.Println("\nキーボードイベントエラーが発生しました。プログラムを終了します...")
                        kh.gracefulShutdown()
                        return</span>
                }
        }
}

// processKey はキー入力を処理
func (kh *KeyboardHandler) processKey(ev termbox.Event) <span class="cov0" title="0">{
        switch ev.Key </span>{
        case termbox.KeyEsc:<span class="cov0" title="0">
                // Escapeキー: 離陸/着陸
                kh.droneController.TakeOffOrLand()</span>

        case termbox.KeySpace:<span class="cov0" title="0">
                // スペースキー: 上昇
                kh.droneController.MoveUp()</span>

        case termbox.KeyCtrlC:<span class="cov0" title="0">
                // Ctrl+C: 終了
                fmt.Println("\nプログラムを終了します...")
                kh.gracefulShutdown()</span>
        }

        // 通常のキー入力
        <span class="cov0" title="0">switch ev.Ch </span>{
        case 'w', 'W':<span class="cov0" title="0">
                // W: 前進
                kh.droneController.MoveForward()</span>

        case 's', 'S':<span class="cov0" title="0">
                // S: 後退
                kh.droneController.MoveBackward()</span>

        case 'a', 'A':<span class="cov0" title="0">
                // A: 左移動
                kh.droneController.MoveLeft()</span>

        case 'd', 'D':<span class="cov0" title="0">
                // D: 右移動
                kh.droneController.MoveRight()</span>

        case 'l', 'L':<span class="cov0" title="0">
                // L: 録画切り替え
                if kh.cameraViewer != nil </span><span class="cov0" title="0">{
                        kh.cameraViewer.ToggleRecording()
                }</span>

        case 'q', 'Q':<span class="cov0" title="0">
                // Q: 終了
                fmt.Println("\nプログラムを終了します...")
                kh.gracefulShutdown()</span>

        case 'z', 'Z':<span class="cov0" title="0">
                // Z: 降下（Shiftキーの代替）
                kh.droneController.MoveDown()</span>
        }
}

// gracefulShutdown はリソースを適切にクリーンアップしてプログラムを終了
func (kh *KeyboardHandler) gracefulShutdown() <span class="cov0" title="0">{
        log.Println("グレースフルシャットダウンを実行中...")

        // キーボードハンドラーを停止
        kh.Stop()

        // ドローンを着陸させる
        if kh.droneController != nil </span><span class="cov0" title="0">{
                log.Println("ドローンを緊急着陸させています...")
                kh.droneController.Land()
        }</span>

        // カメラビューワーを停止
        <span class="cov0" title="0">if kh.cameraViewer != nil </span><span class="cov0" title="0">{
                log.Println("カメラビューワーを停止中...")
                kh.cameraViewer.Stop()
        }</span>

        // 設定されたシャットダウンコールバックを実行
        <span class="cov0" title="0">if kh.shutdownCallback != nil </span><span class="cov0" title="0">{
                kh.shutdownCallback()
        }</span>
}

// IsRunning は実行中かどうかを返す
func (kh *KeyboardHandler) IsRunning() bool <span class="cov8" title="1">{
        return kh.isRunning
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "fmt"
        "log"
        "time"

        "gobot.io/x/gobot"
)

// waitForConnection 接続確認を行い、タイムアウト付きで待機
func waitForConnection(droneController *DroneController, maxWaitTime time.Duration) error <span class="cov0" title="0">{
        log.Println("ドローンに接続中...")
        
        // シンプルな接続確認（実際の実装では、ドローンの状態を確認）
        startTime := time.Now()
        ticker := time.NewTicker(100 * time.Millisecond)
        defer ticker.Stop()
        
        // タイムアウトタイマーをループ外で設定
        timeout := time.After(maxWaitTime)
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        // 実際の接続確認ロジック（ここでは簡略化）
                        if time.Since(startTime) &gt;= time.Second </span><span class="cov0" title="0">{
                                log.Println("準備完了！")
                                return nil
                        }</span>
                case &lt;-timeout:<span class="cov0" title="0">
                        return fmt.Errorf("接続タイムアウト: %v", maxWaitTime)</span>
                }
        }
}

func main() <span class="cov0" title="0">{
        // ドローンコントローラーを作成
        droneController := NewDroneController()
        
        // カメラビューワーを作成
        cameraViewer := NewCameraViewer(droneController.GetDriver())
        
        // キーボードハンドラーを作成
        keyboardHandler := NewKeyboardHandler(droneController, cameraViewer)

        // ドローンの動作を定義する関数
        work := func() </span><span class="cov0" title="0">{
                // カメラビューワーを開始
                cameraViewer.Start()
                
                // キーボードハンドラーを開始
                err := keyboardHandler.Start()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("キーボードハンドラーの開始に失敗: %v", err)
                        return
                }</span>

                // プログラムの説明を表示
                <span class="cov0" title="0">log.Println("=== Tello ドローンコントローラー ===")
                
                // 接続確認のため少し待機
                err = waitForConnection(droneController, 10*time.Second)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("接続エラー: %v", err)
                        return
                }</span>
        }

        // ロボットを作成し、ドローンデバイスを設定
        <span class="cov0" title="0">robot := gobot.NewRobot(
                []gobot.Connection{},
                []gobot.Device{droneController.GetDriver()},
                work,
        )

        // ロボットを開始し、エラーがあれば表示
        err := robot.Start()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("ロボット開始エラー: %v", err)
        }</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
